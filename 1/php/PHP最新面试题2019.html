<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修PHP最新面试题2019' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>PHP最新面试题2019</center></div><div class='banquan'>原文出处:本文由博客园博主幽篁晓筑提供。<br/>
原文连接:https://www.cnblogs.com/woods1815/p/11518474.html</div><br>
    <p>&nbsp;</p>
<h3>1、字符串"0"在PHP和js中转换为布尔值是false还是true</h3>
<p style="margin-left: 30px;">php:false;&nbsp; php 弱语言&nbsp;'0'和0一样；</p>
<p style="margin-left: 30px;">js:true；字符串除了空字符串('')其他都是true（包括' '这种中间有空格的）;</p>
<h3>2、echo， print, print_r, var_dump 区别</h3>
<p style="margin-left: 30px;">echo 语言结构，并不是真正的函数，可以一次输出多个值，多个值之间用逗号分隔。</p>
<p style="margin-left: 30px;">print 是函数，只能输出一个值。</p>
<p style="margin-left: 30px;">print_r 能打印数组，对象。</p>
<p style="margin-left: 30px;">var_dump 能打印数组，对象，并且带数据类型。</p>
<h3>3、程序 $a = "www"; settype($a, 'array'); (string)$a; floatval($a); echo gettype($a); 运行后输出结果：</h3>
<p style="margin-left: 30px;">array&nbsp; 原因：<span style="color: #ff0000;">settype会改变原值的数据类型，string，floatval属于强制转换，不改变原值的数据类型。</span></p>
<h3>4、用PHP实现冒泡排序算法。</h3>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 控制轮次数</span>
<span style="color: #0000ff;">for</span> (<span style="color: #800080;">$i</span> = 1; <span style="color: #800080;">$i</span> &lt; <span style="color: #008080;">count</span>(<span style="color: #800080;">$arr</span>); <span style="color: #800080;">$i</span>++<span style="color: #000000;">) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">控制次数，并判断大小交换位置</span>
    <span style="color: #0000ff;">for</span> (<span style="color: #800080;">$j</span> = 0; <span style="color: #800080;">$j</span> &lt; <span style="color: #008080;">count</span>(<span style="color: #800080;">$arr</span>) - <span style="color: #800080;">$i</span>; <span style="color: #800080;">$j</span>++<span style="color: #000000;">) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">如果当前值大于后面的值</span>
        <span style="color: #0000ff;">if</span> (<span style="color: #800080;">$arr</span>[<span style="color: #800080;">$j</span>] &gt; <span style="color: #800080;">$arr</span>[<span style="color: #800080;">$j</span> + 1<span style="color: #000000;">]) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 交换</span>
            <span style="color: #800080;">$temp</span> = <span style="color: #800080;">$arr</span>[<span style="color: #800080;">$j</span><span style="color: #000000;">];
            </span><span style="color: #800080;">$arr</span>[<span style="color: #800080;">$j</span>] = <span style="color: #800080;">$arr</span>[<span style="color: #800080;">$j</span> + 1<span style="color: #000000;">];
            </span><span style="color: #800080;">$arr</span>[<span style="color: #800080;">$j</span> + 1] = <span style="color: #800080;">$temp</span><span style="color: #000000;">;
        }
    }
}</span></code></pre>

<h3>5、一 群猴子排成一圈，按1，2，&hellip;，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去&hellip;，如此不停的 进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号。</h3>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> $n猴子个数 $m第几个位置</span>
<span style="color: #0000ff;">function</span> fn(<span style="color: #800080;">$n</span>, <span style="color: #800080;">$m</span><span style="color: #000000;">)
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">将猴子数量放到数组内</span>
    <span style="color: #0000ff;">for</span> (<span style="color: #800080;">$i</span> = 1; <span style="color: #800080;">$i</span> &lt; <span style="color: #800080;">$n</span> + 1; <span style="color: #800080;">$i</span>++<span style="color: #000000;">) {
        </span><span style="color: #800080;">$arr</span>[] = <span style="color: #800080;">$i</span><span style="color: #000000;">;
    }
    </span><span style="color: #800080;">$i</span> = 0<span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">当数组内只剩下一个值跳出数组</span>
    <span style="color: #0000ff;">while</span> (<span style="color: #008080;">count</span>(<span style="color: #800080;">$arr</span>) &gt; 1<span style="color: #000000;">) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">遍历数组，判断当前猴子是否为出局序号，如果是则出局，否则放到数组最后</span>
        <span style="color: #0000ff;">if</span> ((<span style="color: #800080;">$i</span> + 1) % <span style="color: #800080;">$m</span> == 0<span style="color: #000000;">) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">当循环次数满足m值 去除掉当前值</span>
            <span style="color: #0000ff;">unset</span>(<span style="color: #800080;">$arr</span>[<span style="color: #800080;">$i</span><span style="color: #000000;">]);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">不满足循环次数 放到数组对尾</span>
            <span style="color: #008080;">array_push</span>(<span style="color: #800080;">$arr</span>, <span style="color: #800080;">$arr</span>[<span style="color: #800080;">$i</span><span style="color: #000000;">]);
            </span><span style="color: #008000;">//</span><span style="color: #008000;">删除掉当前循环内容</span>
            <span style="color: #0000ff;">unset</span>(<span style="color: #800080;">$arr</span>[<span style="color: #800080;">$i</span><span style="color: #000000;">]);
        }
        </span><span style="color: #800080;">$i</span>++<span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">$arr</span><span style="color: #000000;">;
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用</span>
<span style="color: #008080;">var_dump</span>(fn(15,7));</code></pre>

<h3>6、分表，分区，分库，难点是什么？怎么均匀存储数据？</h3>
<p style="margin-left: 30px;"><strong>分表：</strong>即把一个很大的表的数据分到几个表中。</p>
<p style="margin-left: 30px;">分表又分为垂直拆分和水平拆分。</p>
<p style="margin-left: 30px;"><strong>垂直拆分：</strong>把字段拆分；可以把不常用的字段放一张表，把大字段放一张表，把常用的字段放一张表。</p>
<p style="margin-left: 30px;"><strong>水平拆分：</strong>把表数据拆分；可以通过id取模的方式拆分数据，比如要拆分成100张表，user0，user1，user2......，id%100得到的余数即存储到哪张表。</p>
<p style="margin-left: 30px;"><strong>分表难点：</strong>按什么策略来分表；分表后该怎么查询数据（<em>什么情况下该访问哪张表</em>）。</p>
<p>&nbsp;</p>
<p style="margin-left: 30px;"><strong>分区：</strong>所有的数据还在一个表中，但物理存储数据根据一定的规则存放在不同的文件中，文件也可以放到不同的磁盘上。分区的类型：range分区，list分区，hash分区和key分区。</p>
<p style="margin-left: 30px;">常见分区方式：</p>
<p style="margin-left: 30px;">1、根据时间间隔分区，比如以年为单位，分区存储数据。</p>
<p style="margin-left: 30px;">2、根据自增的主键id，hash(id div 10000000) 表示100万数据建立一个分区。</p>
<p>&nbsp;</p>
<p style="margin-left: 30px;"><strong>分库：</strong>把数据分几个库存储。分为垂直分库和水平分库。</p>
<p style="margin-left: 30px;"><strong>垂直分库：</strong>根据表来分数据库，同一类型的表一个数据库；比如博客一个数据库，论坛一个数据库。</p>
<p style="margin-left: 30px;"><strong>水平分库：</strong>根据某些规则，将同一个表的数据分布在不同的库上；比如根据用户id把用户的博客文章分布在5个数据库上。</p>
<h3>7、PHP中单引号和双引号的区别。</h3>
<p style="margin-left: 30px;">在一般情况下，单引号和双引号是可以互通的，但<span style="color: #ff0000;">双引号内部变量会解析，而单引号内部变量不解析</span>。</p>
<h3>8、require()和include()的区别。</h3>
<p style="margin-left: 30px;">都是引入别的页面；</p>
<p style="margin-left: 30px;"><span style="color: #ff0000;">require()出现错误，会终止程序；而include()则会继续执行，并会显示一个错误警告；</span></p>
<p style="margin-left: 30px;">在实际项目中，一般使用require_one()更好。</p>
<h3>9、PHP中超全局变量，魔术变量，魔术方法：</h3>
<p style="margin-left: 30px;"><strong>超全局变量（9个）：</strong></p>
<p style="margin-left: 30px;">参考：<a href="https://www.php.net/manual/zh/language.variables.superglobals.php" target="_blank">https://www.php.net/manual/zh/language.variables.superglobals.php</a></p>
<p style="margin-left: 30px;">$GLOBALS</p>
<p style="margin-left: 30px;">$_SERVER</p>
<p style="margin-left: 30px;">$_REQUEST</p>
<p style="margin-left: 30px;">$_POST</p>
<p style="margin-left: 30px;">$_GET</p>
<p style="margin-left: 30px;">$_FILES</p>
<p style="margin-left: 30px;">$_ENV</p>
<p style="margin-left: 30px;">$_COOKIE</p>
<p style="margin-left: 30px;">$_SESSION</p>
<p style="margin-left: 30px;"><strong>魔术变量（8个）：</strong></p>
<p style="margin-left: 30px;">__LINE__&nbsp; &nbsp;&nbsp;文件中的当前行号。</p>
<p style="margin-left: 30px;">__FILE__&nbsp; &nbsp;&nbsp;文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。</p>
<p style="margin-left: 30px;">__DIR__&nbsp; &nbsp; &nbsp;文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。</p>
<p style="margin-left: 30px;">__FUNCTION__&nbsp; &nbsp; 返回该函数被定义时的名字（区分大小写）</p>
<p style="margin-left: 30px;">__CLASS__&nbsp; &nbsp; 返回该类被定义时的名字（区分大小写）。</p>
<p style="margin-left: 30px;">__TRAIT__&nbsp; &nbsp; Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。</p>
<p style="margin-left: 30px;">__METHOD__&nbsp; &nbsp; &nbsp;返回该方法被定义时的名字（区分大小写）。</p>
<p style="margin-left: 30px;">__NAMESPACE__&nbsp; &nbsp; 当前命名空间的名称（区分大小写）。</p>
<p style="margin-left: 30px;"><strong>魔术方法：</strong></p>
<p style="margin-left: 30px;">参考：<a href="https://www.php.net/manual/zh/language.oop5.magic.php" target="_blank">https://www.php.net/manual/zh/language.oop5.magic.php</a></p>
<h3>10、栈和队列</h3>
<p style="margin-left: 30px;"><strong>栈：</strong>是允许在同一端进行插入和删除的特殊线性表。</p>
<p style="margin-left: 30px;">栈也称为<span style="color: #ff0000;">先进后出</span>表。</p>
<p style="margin-left: 30px;">注：线性表是最基本，最简单，也是最常用的一种数据结构。线性表中数据元素之间的关系是一对一的关系。</p>
<p style="margin-left: 30px;"><strong>队列：</strong>是一种特殊的线性表。特殊之处在于只允许在前端进行删除操作，在表的后端进行插入操作。</p>
<p style="margin-left: 30px;">队列也称为<span style="color: #ff0000;">先进先出</span>表。</p>
<h3>11、对称加密和非对称加密</h3>
<p style="margin-left: 30px;">对称加密指的就是加密和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥，作为私钥。&nbsp;</p>
<p style="margin-left: 30px;">常见的<strong>对称加密</strong>算法：<span style="color: #ff0000;">DES，AES，3DES等等。</span></p>
<p style="margin-left: 30px;">非对称加密指的是：加密和解密使用不同的秘钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。&nbsp;</p>
<p style="margin-left: 30px;">常见的<strong>非对称加密</strong>算法：<span style="color: #ff0000;">RSA，ECC（移动设备用），DSA（数字签名用）</span></p>
<h3>12、时间复杂度和空间复杂度</h3>
<p style="margin-left: 30px;">算法复杂度分为时间复杂度和空间复杂度。</p>
<p style="margin-left: 30px;">其作用：时间复杂度是指执行算法所需要的计算工作量；而空间复杂度是指执行这个算法所需要的内存空间。</p>
<h3>13、抽象类和接口的区别</h3>
<p style="margin-left: 30px;">参考：<a href="https://blog.csdn.net/sunlylorn/article/details/6124319" target="_blank">https://blog.csdn.net/sunlylorn/article/details/6124319</a></p>
<h3>14、PHP创建多级目录</h3>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span> makedir(<span style="color: #800080;">$path</span><span style="color: #000000;">)
{
    </span><span style="color: #0000ff;">if</span> (<span style="color: #008080;">is_dir</span>(<span style="color: #800080;">$path</span><span style="color: #000000;">)){
        </span><span style="color: #0000ff;">echo</span> "目录已存在"<span style="color: #000000;">;
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
        </span><span style="color: #800080;">$res</span> = <span style="color: #008080;">mkdir</span>(<span style="color: #800080;">$path</span>, 0777, <span style="color: #0000ff;">true</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (<span style="color: #800080;">$res</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">echo</span> "创建成功"<span style="color: #000000;">;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">echo</span> "创建失败"<span style="color: #000000;">;
        }
    }
}</span></code></pre>

<h3>15、PHP写一段代码，确保多个进程同时写入一个文件成功</h3>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span> writeData(<span style="color: #800080;">$filepath</span>, <span style="color: #800080;">$data</span><span style="color: #000000;">)
{
    </span><span style="color: #800080;">$fp</span> = <span style="color: #008080;">fopen</span>(<span style="color: #800080;">$filepath</span>, 'a');  <span style="color: #008000;">//</span><span style="color: #008000;">以追加的方式打开文件，返回的是指针</span>
    <span style="color: #0000ff;">do</span><span style="color: #000000;"> {
        </span><span style="color: #008080;">usleep</span>(100);    <span style="color: #008000;">//</span><span style="color: #008000;">暂停执行程序，参数是以微秒为单位的</span>
    } <span style="color: #0000ff;">while</span> (!<span style="color: #008080;">flock</span>(<span style="color: #800080;">$fp</span>, LOCK_EX));  <span style="color: #008000;">//</span><span style="color: #008000;">LOCK_EX 取得独占锁定（写入的程序）进行排它型锁定 获取锁　有锁就写入，没锁就得</span>
    <span style="color: #800080;">$res</span> = <span style="color: #008080;">fwrite</span>(<span style="color: #800080;">$fp</span>, <span style="color: #800080;">$data</span> . "\n");  <span style="color: #008000;">//</span><span style="color: #008000;"> 以追加的方式写入数据到打开的文件</span>
    <span style="color: #008080;">flock</span>(<span style="color: #800080;">$fp</span>, LOCK_UN);    <span style="color: #008000;">//</span><span style="color: #008000;">LOCK_UN 释放锁定（无论共享或独占）。</span>
    <span style="color: #008080;">fclose</span>(<span style="color: #800080;">$fp</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">关闭打开的文件指针</span>
    <span style="color: #0000ff;">return</span> <span style="color: #800080;">$res</span><span style="color: #000000;">;
}</span></code></pre>

<h3>16、PHP的is_writeable()函数存在Bug，无法准确判断一个目录/文件是否可写，请写一个函数来判断目录/文件是否绝对可写。</h3>
<p style="margin-left: 30px;">下面是CodeIgniter 中的is_really_writable函数解决方案，详见函数注释</p>
<p style="margin-left: 30px;">其中bug存在两个方面，</p>
<p style="margin-left: 30px;">1、在windowns中，当文件只有只读属性时，is_writeable()函数才返回false，当返回true时，该文件不一定是可写的。</p>
<p style="margin-left: 30px;">如果是目录，在目录中新建文件并通过打开文件来判断；</p>
<p style="margin-left: 30px;">如果是文件，可以通过打开文件（fopen），来测试文件是否可写。</p>
<p style="margin-left: 30px;">2、在Unix中，当php配置文件中开启safe_mode时(safe_mode=on)，is_writeable()同样不可用。</p>
<p style="margin-left: 30px;">读取配置文件是否safe_mode是否开启。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Tests for file writability
 *
 * is_writable() returns TRUE on Windows servers when you really can't write to
 * the file, based on the read-only attribute. is_writable() is also unreliable
 * on Unix servers if safe_mode is on.
 *
 * @access private
 * @return void
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">if</span> ( ! <span style="color: #008080;">function_exists</span>('is_really_writable'<span style="color: #000000;">)) {
    </span><span style="color: #0000ff;">function</span> is_really_writable(<span style="color: #800080;">$file</span><span style="color: #000000;">)
    {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> If we're on a Unix server with safe_mode off we call is_writable</span>
        <span style="color: #0000ff;">if</span> (DIRECTORY_SEPARATOR == '/' AND @<span style="color: #008080;">ini_get</span>("safe_mode") == <span style="color: #0000ff;">FALSE</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #008080;">is_writable</span>(<span style="color: #800080;">$file</span><span style="color: #000000;">);
        }
 
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> For windows servers and safe_mode "on" installations we'll actually
        // write a file then read it. Bah...</span>
        <span style="color: #0000ff;">if</span> (<span style="color: #008080;">is_dir</span>(<span style="color: #800080;">$file</span><span style="color: #000000;">)) {
            </span><span style="color: #800080;">$file</span> = <span style="color: #008080;">rtrim</span>(<span style="color: #800080;">$file</span>, '/') . '/' . <span style="color: #008080;">md5</span>(<span style="color: #008080;">mt_rand</span>(1, 100) . <span style="color: #008080;">mt_rand</span>(1, 100<span style="color: #000000;">));
 
            </span><span style="color: #0000ff;">if</span> ((<span style="color: #800080;">$fp</span> = @<span style="color: #008080;">fopen</span>(<span style="color: #800080;">$file</span>, FOPEN_WRITE_CREATE)) === <span style="color: #0000ff;">FALSE</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">FALSE</span><span style="color: #000000;">;
            }
 
            </span><span style="color: #008080;">fclose</span>(<span style="color: #800080;">$fp</span><span style="color: #000000;">);
            @</span><span style="color: #008080;">chmod</span>(<span style="color: #800080;">$file</span>,<span style="color: #000000;"> DIR_WRITE_MODE);
            @</span><span style="color: #008080;">unlink</span>(<span style="color: #800080;">$file</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">TRUE</span><span style="color: #000000;">;
        } </span><span style="color: #0000ff;">elseif</span> (!<span style="color: #008080;">is_file</span>(<span style="color: #800080;">$file</span>) OR (<span style="color: #800080;">$fp</span> = @<span style="color: #008080;">fopen</span>(<span style="color: #800080;">$file</span>, FOPEN_WRITE_CREATE)) === <span style="color: #0000ff;">FALSE</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">FALSE</span><span style="color: #000000;">;
        }
 
        </span><span style="color: #008080;">fclose</span>(<span style="color: #800080;">$fp</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">TRUE</span><span style="color: #000000;">;
    }
}</span></code></pre>

<h3>17、php中去除一个字符串中非字母部分</h3>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;">preg_replace</span>('/[^a-z]/i', '', <span style="color: #800080;">$str</span>);</code></pre>

<h3>18、将一个字符串去除字符串中非字母部分，并将字符串中&rsquo;_&lsquo;号后面首字母和字符串首字母大写，如a2b_ab23c得到AbAbc。</h3>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span> getStr(<span style="color: #800080;">$str</span><span style="color: #000000;">)
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> [^a-z]用来匹配任何不在a和z之间的字符，i表示不区分大小写。</span>
    <span style="color: #800080;">$str</span> = <span style="color: #008080;">preg_replace</span>('/[^a-z_]/i', '', <span style="color: #800080;">$str</span><span style="color: #000000;">);
    </span><span style="color: #800080;">$arr</span> = <span style="color: #008080;">explode</span>('_', <span style="color: #800080;">$str</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">foreach</span>(<span style="color: #800080;">$arr</span> <span style="color: #0000ff;">as</span> <span style="color: #800080;">$key</span>=&gt;<span style="color: #800080;">$value</span><span style="color: #000000;">){
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> ucfirst()首字母大写</span>
        <span style="color: #800080;">$arr</span>[<span style="color: #800080;">$key</span>] = <span style="color: #008080;">ucfirst</span>(<span style="color: #800080;">$value</span><span style="color: #000000;">);
    }
    </span><span style="color: #800080;">$str</span> = <span style="color: #008080;">implode</span>('', <span style="color: #800080;">$arr</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">echo</span> <span style="color: #800080;">$str</span><span style="color: #000000;">;
}
getStr(</span>'a2b_ab23c');</code></pre>

<h3>19、使用js实现进入一个页面10s后弹出提示框，提示框内容为&lsquo;hello world&rsquo;。</h3>
<src class="cnblogs_code">
<pre><code>setTimeout("alert('hello world')", 10000)</code></pre>

<h3>20、写一个sql语句查询表A中user_name字段重复出现两次以上的所有数据。</h3>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">user_name</span>, <span style="color: #ff00ff;">COUNT</span>(<span style="color: #ff00ff;">user_name</span>) <span style="color: #0000ff;">AS</span><span style="color: #000000;"> num 
        </span><span style="color: #0000ff;">FROM</span> A <span style="color: #0000ff;">GROUP</span> <span style="color: #0000ff;">BY</span> <span style="color: #ff00ff;">user_name</span> <span style="color: #0000ff;">HAVING</span> num <span style="color: #808080;">&gt;=</span><span style="color: #800000; font-weight: bold;">2</span>;</code></pre>

<p><span style="color: #ff0000;">注意</span>：</p>
<ul>
<li>having只能用在group by之后，对分组后的结果进行筛选(即使用having的前提条件是分组)。</li>
<li>where肯定在group by 之前。</li>
<li>where后的条件表达式里不允许使用聚合函数，而having可以。</li>
</ul>
<h3>21、redis内存满了之后怎么处理的</h3>
<p style="margin-left: 30px;">参考博客：<a href="https://blog.csdn.net/qq_28018283/article/details/80764518" target="_blank">https://blog.csdn.net/qq_28018283/article/details/80764518</a></p>
<p style="margin-left: 30px;">如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以将Redis当缓存来使用配置淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。有5中内存淘汰机制，具体看参考博客。</p>
<h3>22、PHP互换两个变量值的方法(不用第三变量)</h3>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">function</span><span style="color: #000000;"> exchange()
{
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">*
     * 双方变量为字符串或者数字时，可用此交换方法
     * 使用异或运算
     </span><span style="color: #008000;">*/</span>
    <span style="color: #800080;">$a</span> = "This is A"; <span style="color: #008000;">//</span><span style="color: #008000;"> a变量原始值</span>
    <span style="color: #800080;">$b</span> = "This is B"; <span style="color: #008000;">//</span><span style="color: #008000;"> b变量原始值</span>
    <span style="color: #0000ff;">echo</span> '交换之前 $a 的值：' . <span style="color: #800080;">$a</span> . ', $b 的值：' . <span style="color: #800080;">$b</span>, '&lt;br&gt;'; <span style="color: #008000;">//</span><span style="color: #008000;"> 输出原始值</span>
    <span style="color: #008000;">/*</span><span style="color: #008000;">*
     * 原始二进制：
     * $a:010101000110100001101001011100110010000001101001011100110010000001000001
     * $b:010101000110100001101001011100110010000001101001011100110010000001000010
     *
     * 下面主要使用按位异或交换，具体请参照下列给出的二进制过程，
     </span><span style="color: #008000;">*/</span>
    <span style="color: #800080;">$a</span> = <span style="color: #800080;">$a</span> ^ <span style="color: #800080;">$b</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> 此刻$a:000000000000000000000000000000000000000000000000000000000000000000000011</span>
    <span style="color: #800080;">$b</span> = <span style="color: #800080;">$b</span> ^ <span style="color: #800080;">$a</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> 此刻$b:010101000110100001101001011100110010000001101001011100110010000001000001</span>
    <span style="color: #800080;">$a</span> = <span style="color: #800080;">$a</span> ^ <span style="color: #800080;">$b</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> 此刻$a:010101000110100001101001011100110010000001101001011100110010000001000010</span>
    <span style="color: #0000ff;">echo</span> '交换之后 $a 的值：' . <span style="color: #800080;">$a</span> . ', $b 的值：' . <span style="color: #800080;">$b</span>, '&lt;br&gt;'; <span style="color: #008000;">//</span><span style="color: #008000;"> 输出结果值</span>
}</code></pre>

<p>&nbsp;</p>

</div></div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>