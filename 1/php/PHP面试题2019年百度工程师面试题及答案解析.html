<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修PHP面试题2019年百度工程师面试题及答案解析' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>PHP面试题2019年百度工程师面试题及答案解析</center></div><div class='banquan'>原文出处:本文由博客园博主PHP程序媛提供。<br/>
原文连接:https://www.cnblogs.com/993089249a/p/11648198.html</div><br>
    <p><strong>一、单选题（共10题，每题5分）</strong></p>
<p><strong>1.以下代码输出的结果是？</strong></p>
<p>​​​<img src="./images/PHP面试题2019年百度工程师面试题及答案解析0.jpg" alt="" /></p>
<p>A、[0,1,2,3]</p>
<p>B、[1,3,5,7,5]</p>
<p>C、[1,2,3,4,5]</p>
<p>D、[0,1,2,3,5]</p>
<p><strong>参考答案：D</strong></p>
<p>答案解析：</p>
<p>考的是数组+和array_merge的区别 当下标为数值时，array_merge()不会覆盖掉原来的值，但array＋array合并数组则会把最先出现的值作为最终结果返回，而把后面的数组拥有相同键名的那些值&ldquo;抛弃&rdquo;掉（不是覆盖）. 当下标为字符时，array＋array仍然把最先出现的值作为最终结果返回，而把后面的数组拥有相同键名的那些值&ldquo;抛弃&rdquo;掉，但array_merge()此时会覆盖掉前面相同键名的值.</p>
<p>&nbsp;</p>
<p><strong>2.以下代码执行结果是？</strong></p>
<src class="image-package"><img class="uploaded-img" src="./images/PHP面试题2019年百度工程师面试题及答案解析1.jpg" alt="" width="auto" height="auto" />
<src class="image-package">A、0
<src class="image-package">
<p>B、1</p>
<p>C、2</p>
<p>D、3</p>
<p><strong>参考答案：B</strong></p>
<p>答案解析：</p>
<p>如果你回答 2 ，恭喜，你掉入陷阱了。 其实这道题主要考两点，第一点是static静态类型。这种的值永远都是静态的，第一次调用声明等于0，并且自增等于1。第二次调用，1再自增就等于2。但其实这里还有一道陷阱，那就是++a与a++的区别，前++是先自增，后++是先返回值再自增，所以结果等于 1。</p>
<p>&nbsp;</p>
<p><strong>3.以下PHP代码执行的结果是？</strong></p>
<src class="image-package"><img class="uploaded-img" src="./images/PHP面试题2019年百度工程师面试题及答案解析2.jpg" alt="" width="auto" height="auto" /><br />
<src class="image-caption">A、[1,2,3]





<p>B、[1,2,2]</p>
<p>C、[1,1,2]</p>
<p>D、[1,3,2]</p>
<p><strong>参考答案：B</strong></p>
<p>答案解析：</p>
<p>在 PHP 中，foreach 结束后，循环中的索引值（index）及內容（value）並不会被重置。 所以最后的 $v还指向最后一个元素，再次循环，就会把最后个元素的值修改掉了。</p>
<p>解决的办法是，循环完毕之后，用unset($v); https://www.php.net/manual/en/control-structures.foreach.php</p>
<p>&nbsp;</p>
<p><strong>4.php执行过程的顺序正确的是？</strong></p>
<p>A、扫描-&gt;解析-&gt;编译-&gt;执行-&gt;输出</p>
<p>B、扫描-&gt;解析-&gt;执行-&gt;编译-&gt;输出</p>
<p>C、扫描-&gt;编译-&gt;解析-&gt;执行-&gt;输出</p>
<p>D、扫描-&gt;执行-&gt;编译-&gt;解析-&gt;输出</p>
<p><strong>参考答案：A</strong></p>
<p>答案解析：</p>
<p>PHP简化执行过程： 1.扫描(scanning) ,将index.php内容变成一个个语言片段(token) 2.解析(parsing) , 将一个个语言片段变成有意义的表达式 3.编译(complication),将表达式编译成中间码(opcode) 4.执行(execution),将中间码一条一条的执行 5.输出(output buffer),将要输出的内容输出到缓冲区</p>
<p><strong><a href="https://jq.qq.com/?_wv=1027&amp;k=5HQD3Io" target="_blank">&nbsp;</a></strong></p>
<p><strong>5.php垃圾回收机制的说法错误的是？</strong></p>
<p>A、在一个垃圾周期中，通过检查引用计数是否减1，并且检查哪些变量容器的引用次数是零，来发现哪部分是垃圾</p>
<p>B、可以通过调用gc_enable() 和 gc_disable()函数来打开和关闭垃圾回收机制</p>
<p>C、通过清理未被使用的变量来节省内存的占用</p>
<p>D、php代码执行完毕后会自动执行垃圾回收，所以不需要手动执行垃圾回收</p>
<p><strong>参考答案：D</strong></p>
<p>答案解析：</p>
<p>php一段代码有可能要长时间执行，但若此期间有未引用的变量的话，就会占用内存的空间，导致运行缓慢等问题</p>
<p>&nbsp;</p>
<p><strong>6.关于XSS防御，错误的是？</strong></p>
<p>A、禁止字符</p>
<p>B、限制字符(reg_match)</p>
<p>C、过滤(preg_replace)</p>
<p>D、转义标签(htmlspecialchars)</p>
<p><strong>参考答案：A</strong></p>
<p>答案解析：</p>
<p>转义标签(htmlspecialchars) 限制字符(reg\_match) 过滤(preg\_replace) http only 模板引擎</p>
<p>&nbsp;</p>
<p><strong>7.有一个文件ip.txt，每行一条ip记录，共若干行，下面哪个命令可以实现&ldquo;统计出现次数最多的前3个ip及其次数&rdquo;？（ ）</strong></p>
<p>A、uniq -c ip.txt</p>
<p>B、sort -nr ip.txt | uniq -c | sort -nr | head -n 3</p>
<p>C、cat ip.txt | count -n | sort -rn | head -n 3</p>
<p>D、cat ip.txt | count -n</p>
<p><strong>参考答案：B</strong></p>
<p>答案解析：</p>
<p>本题利用管道符"|"组合多个命令，uniq -c filename用于去除冗余并统计每一行出现的次数。 sort -r指逆序排序，-n指按数字字符串大小排序 head指定数量。 剩下的二选一交给运气。</p>
<p>正确的命令应该为： sort -nr ip.txt | uniq -c | sort -nr | head -n 3 第一次排序，把ip按顺序排列，因为第二个uniq只会合并相邻项 第二次排序，才是把ip按出现次序大小从大到小排列 最后取前三项结果。</p>
<p>&nbsp;</p>
<p><strong>8.Mysql索引使用的B-Tree描述错误的是？</strong></p>
<p>A、每个非叶子结点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d；</p>
<p>B、每个叶子结点至少包含一个key和两个指针</p>
<p>C、所有叶结点都在同一层，深度等于树高h.</p>
<p>D、一个结点中的key从左至右递减排列</p>
<p><strong>参考答案：D</strong></p>
<p>答案解析：</p>
<p>B-Tree是满足条件： d&gt;=2，即B-Tree的度； h为B-Tree的高； 每个非叶子结点由n-1个key和n个指针组成，其中d</p>










<br />
<p><strong>9.下列哪个是创建一个每周三01:00~04:00每3分钟执行执行一次的crontab指令？</strong></p>
<p>A、* 1,4 * * 3 /bin/bash /home/sijiaomao/ok.sh</p>
<p>B、*/3 1,4 * * 3 /bin/bash /home/sijiaomao/ok.sh</p>
<p>C、*/3 1-4 * * 3 /bin/bash /home/sijiaomao/ok.sh</p>
<p>D、*/3 1-4 * * * /bin/bash /home/sijiaomao/ok.sh</p>
<p><strong>参考答案：C</strong></p>
<p>答案解析：</p>
<p>A：每周三的1时4时每分钟执行一次 B：每周三的1时4时每3分钟执行一次 C：满足要求 D：每天的1时4时每3分钟执行一次</p>
<p>&nbsp;</p>
<p><strong>10.正则的引擎表述错误的是？</strong></p>
<p>A、正则引擎主要可以分为两大类：一种是DFA，一种是NFA。</p>
<p>B、一般而论，NFA引擎则搜索更快一些。但是DFA以表达式为主导，更容易操纵，因此一般程序员更偏爱DFA引擎！</p>
<p>C、NFA表达式主导,DFA文本主导.</p>
<p>D、可以使用是否支持忽略优先量词和分组捕获来判断引擎类型：支持 NFA,不支持 DFA</p>
<p>&nbsp;</p>
<p>很多人在刚接触这个行业的时候或者是在遇到瓶颈期的时候，总会遇到一些问题，比如学了一段时间感觉没有方向感，不知道该从那里入手去学习，对此我整理了一些资料，需要的可以免费分享给大家<a href="https://link.zhihu.com/?target=https%3A//jq.qq.com/%3F_wv%3D1027%26k%3D55dPDrC" target="_blank">（11年架构师带你解读年薪50万面试通关秘籍。）</a></p>
<p>如果喜欢我的文章，想与一群资深开发者一起交流学习的话，获取更多相关大厂面试咨询和指导，欢迎加入我的学习交流群<a title="PHP高级学习交流" href="https://link.zhihu.com/?target=https%3A//jq.qq.com/%3F_wv%3D1027%26k%3D5kN6y8c" target="_blank">点击此处PHP高级交流</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>二、多选题（共10题，每题5分）</strong></p>
<p><strong>1.HTTP中GET与POST的区别有哪些？</strong></p>
<p>A、GET在浏览器回退时是无害的，而POST会再次提交请求</p>
<p>B、GET请求只能进行url编码，而POST支持多种编码方式</p>
<p>C、GET请求会被浏览器主动cache，而POST不会，除非手动设置。</p>
<p>D、GET产生一个TCP数据包，POST产生两个TCP数据包。</p>
<p>&nbsp;</p>
<p><strong>2.MySQL有一个复合索引：INDEX(`a`, `b`, `c`)，以下查询能用上索引的有？</strong></p>
<p>A、select * from users where a = 1 and b = 2</p>
<p>B、select * from users where b = 2 and a = 1</p>
<p>C、select * from users where a = 2 and c = 1</p>
<p>D、select * from users where b = 2 and c = 1</p>
<p><strong>3.为什么大型网站要使用消息队列？</strong></p>
<p>A、解耦</p>
<p>B、异步</p>
<p>C、削峰</p>
<p>D、大数据处理</p>
<p>。</p>
<p><strong>4.关于Memcache与Redis的说法正确的有？</strong></p>
<p>A、Memcache单个key（变量）存放的数据有2M的限制, Redis单个key（变量）存放的数据有1GB的限制</p>
<p>B、Memcache存储数据的类型都是String类型，Redis数据类型比较丰富:String、List、Set、Sortedset、Hash</p>
<p>C、Memcache可以使用多核（多线程），而Redis只是支持单线程</p>
<p>D、Memcache服务器突然断电，则全部数据就会丢失； 而Redis有持久化功能，可以把数据随时存储在磁盘上</p>
<p>&nbsp;</p>
<p><strong>5关于缓存雪崩的事前事中事后的解决方案正确的有？</strong></p>
<p>A、事前：进行系统压力测试，在负载均衡层做限流处理，过载丢弃请求或者进入队列</p>
<p>B、事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。</p>
<p>C、事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</p>
<p>D、事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</p>
<p>&nbsp;</p>
<p><strong>6.设计一个高并发系统，需要重点考虑的问题有？</strong></p>
<p>A、系统拆分</p>
<p>B、缓存</p>
<p>C、MQ</p>
<p>D、分库分表</p>
<p>E、读写分离</p>
<p>F、ElasticSearch</p>
<p>&nbsp;</p>
<p><strong>7.关于PHP-FPM子进程数量说法正确的有？</strong></p>
<p>A、PHP-FPM 子进程数量不能太多，太多了增加进程管理的开销以及上下文切换的开销</p>
<p>B、dynamic 方式下，最合适的子进程数量为 在 N + 20% 和 M / m 之间 （N 是 CPU 内核数量，M 是 PHP 能利用的内存数量，m 是每个 PHP 进程平均使用的内存数量）</p>
<p>C、static方式：M / (m * 1.2) （M 是 PHP 能利用的内存数量，m 是每个 PHP 进程平均使用的内存数量）</p>
<p>D、pm.max_requests 可以随便设置 ,但是为了预防内存泄漏的风险，还是设置一个合理的数比较好</p>
<p>&nbsp;</p>
<p><strong>8.关于Kafka、ActiveMQ、RabbitMQ、RocketMQ说法正确的有？</strong></p>
<p>A、ActiveMQ 基于 erlang 开发，并发能力很强，性能极好，延时很低</p>
<p>B、RocketMQ topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，在同等机器下，可以支撑大量的 topic</p>
<p>C、RabbitMQ时效性是微秒级，这是 RabbitMQ 的一大特点，延迟最低</p>
<p>D、Kafka 单机吞吐量 10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</p>
<p>&nbsp;</p>
<p><strong>9.分库分表之后，id 主键如何处理？</strong></p>
<p>A、单库生成自增 id</p>
<p>B、设置数据库 sequence 或者表自增字段步长</p>
<p>C、UUID</p>
<p>D、snowflake 算法</p>
<p>&nbsp;</p>
<p><strong>10.Redis 内存淘汰机制有哪些？</strong></p>
<p>A、noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错</p>
<p>B、allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key</p>
<p>C、volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key</p>
<p>D、allkeys-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。</p>
<p>&nbsp;</p>
<p><strong>&nbsp;</strong></p>
<p>​&nbsp;</p>
















<p>&nbsp;</p>

</div></div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>