<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修RdKafka文档翻译' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>RdKafka文档翻译</center></div><div class='banquan'>原文出处:本文由博客园博主WebLinuxStudy提供。<br/>
原文连接:https://www.cnblogs.com/WebLinuxStudy/p/11547428.html</div><br>
    <p>函数<br />string rd_kafka_err2str ( integer $err ) 将rdkafka错误代码转换为字符串</p>
<p>integer rd_kafka_errno2err ( integer $errnox ) 将系统errno转换为Kafka错误代码</p>
<p>integer rd_kafka_errno ( void ) 返回系统errno</p>
<p>integer rd_kafka_offset_tail ( integer $cnt ) 返回一个特殊的偏移量值，该值可用于在主题尾部之前开始使用cnt消息</p>
<p>RdKafka\KafkaConsume类<br />这是高水平消费者，支持自动分区/撤销（pecl rdkafka&gt;=1.0.0,librdkafka&gt;=0.9）</p>
<p>1)public void RdKafka\KafkaConsumer::assign ([ array $topic_partitions = NULL ] )<br />更新分配集到$topic_partitions,可以通过调用RdKafka\Conf::setDefaultTopicConf()来更改主题的默认配置<br />$kafkaConsumer-&gt;assign([<br />    new RdKafka\TopicPartition("logs", 0),<br />    new RdKafka\TopicPartition("logs", 1),<br />]);</p>
<p>2)public void RdKafka\KafkaConsumer::commit ([ mixed $message_or_offsets = NULL ] )<br />同步提交偏移，直到提交偏移或提交失败为止。<br />如果注册了COMMIT_CB回调，那么它将被调用，并包含未来要使用的调用的提交详细信息。<br />参数<br />message_or_offsets<br />When NULL, commit offsets for the current assignment.<br />When a RdKafka\Message, commit offset for a single topic+partition based on the message.<br />When an array of RdKafka\TopicPartition, commit offsets for the provided list of partitions.<br />异常<br />Errors/Exceptions<br />Throws RdKafka\Exception on errors.<br />例子:<br />// Commit offsets for the current assignment<br />$kafkaConsumer-&gt;commit();</p>
<p>// Commit offsets based on the message's topic, partition, and offset<br />$kafkaConsumer-&gt;commit($message);</p>
<p>// Commit offsets by providing a list of TopicPartition<br />$kafkaConsumer-&gt;commit([<br />    new RdKafka\TopicPartition($topic, $partition, $offset),<br />]);</p>
<p>3)public void RdKafka\KafkaConsumer::commitAsync ([ string $message_or_offsets = NULL ] )<br />异步提交偏移<br />4)public RdKafka\KafkaConsumer::__construct ( RdKafka\Conf $conf )<br />参数<br />conf (RdKafka\Conf)<br />The conf object must have group.id set to the consumer group to join.<br />conf对象必须将Group.id设置为要加入的消费者组。<br />示例：<br />$conf = new RdKafka\Conf();<br />$conf-&gt;set("group.id", "myGroupID");</p>
<p>$kafkaConsumer = new RdKafka\KafkaConsumer($conf);<br />5)public RdKafka\Message RdKafka\KafkaConsumer::consume ( string $timeout_ms )<br />使用消息或获取错误事件，触发回调<br />将自动调用任何此类排队事件的已注册回调，包括rebalance_cb, event_cb, commit_cb, etc.<br />参数<br />timeout_ms (int)  超时时间(milliseconds)<br />返回值<br />Returns a RdKafka\Message. On error or timeout, RdKafka\Message::$err is != RD_KAFKA_ERR_NO_ERROR, and other properties should be ignored.<br />注意：<br />应用程序应确保定期调用consume ()，即使没有预期的消息，为等待调用的排队回调提供服务，当rebalnce_cb已经注册时，这一点尤其重要，因为需要正确地调用和处理它，以同步内部使用者状态。</p>
<p><br />while (true) {<br />    $message = $kafkaConsumer-&gt;consume(3600e3);<br />    switch ($message-&gt;err) {<br />        case RD_KAFKA_RESP_ERR_NO_ERROR:<br />            handle($message);<br />            break;<br />        case RD_KAFKA_RESP_ERR__TIMED_OUT:<br />            echo "Timedout\n";<br />            break;<br />        default:<br />            throw new \Exception($message-&gt;errstr());<br />            break;<br />    }<br />}</p>
<p>6)public array RdKafka\KafkaConsumer::getAssignment ( void )<br />返回由assign设置 或 再平衡的 当前分区分配集<br />Returns the current partition assignment as set by RdKafka\KafkaConsumer::assign() or by rebalancing.<br />返回值<br />Returns an array of RdKafka\TopicPartition 返回RdKafka\Topic分区的数组<br />Errors/Exceptions<br />Throws RdKafka\Exception on errors.</p>
<p>6)public RdKafka\Metadata RdKafka\KafkaConsumer::getMetadata ( bool $all_topics , RdKafka\KafkaConsumerTopic $only_topic = NULL , int $timeout_ms)<br />向代理请求元数据</p>
<p>参数<br />all_topics (bool)<br />When TRUE, request info about all topics in cluster. Else, only request info about locally known topics.如果为真，请求有关集群中所有主题的信息。否则，只请求有关本地已知主题的信息<br />only_topic (RdKafka\KafkaConsumerTopic) <br />When non-null, only request info about this topic当非空时，只请求有关此主题的信息。<br />timeout_ms (int)<br />Timeout (milliseconds) 超时</p>
<p>返回值<br />Returns a RdKafka\Metadata instance <br />示例<br />$all = $kafkaConsumer-&gt;metadata(true, NULL, 60e3);</p>
<p>$local = $kafkaConsumer-&gt;metadata(false, NULL, 60e3);</p>
<p>$topic = $kafkaConsumer-&gt;newTopic("myTopic");<br />$one = $kafkaConsumer-&gt;metadata(true, $topic, 60e3);</p>
<p>7)public array RdKafka\KafkaConsumer::getSubscription ( void )<br />返回RdKafka\KafkaConsumer：subscribe()设置的当前订阅<br />Return the current subscription as set by RdKafka\KafkaConsumer::subscribe()<br />返回值<br />Returns an array of topic names 返回主题名称数组</p>
<p>8)public void RdKafka\KafkaConsumer::subscribe ( array $topics ) <br />将订阅集更新为主题。<br />这将覆盖当前任务。任何先前的订阅都将首先被取消分配和取消订阅。<br />订阅集表示要消费的所需主题.......<br />可以通过调用RdKafka\Conf::setDefaultTopicConf()更改订阅主题的默认配置。</p>
<p>$kafkaConsumer-&gt;assign([<br />    "logs",<br />    "^myPfx[0-9]_.*",<br />]);</p>
<p>9)public ReturnType RdKafka\KafkaConsumer::unsubscribe ( void )<br />从当前订阅集取消订阅</p>
<p>RdKafka\KafkaConsumerTopic类<br />(PECL rdkafka &gt;= 1.0.0, librdkafka &gt;= 0.9)<br />This class represents a topic when using the RdKafka\KafkaConsumer. It can not be instantiated directly, RdKafka\KafkaConsumer::newTopic() should be used instead.<br />当想使用RdKafka\KafkaConsumer去表示一个主题的时候，不能直接实例化，应该使用RdKafka\KafkaConsumer::newTopic()替代</p>
<p>1)public void RdKafka\KafkaConsumerTopic::offsetStore ( integer $partition , integer $offset )<br />Store offset offset for topic partition partition. The offset will be commited (written) to the offset store according to auto.commit.interval.ms.<br />auto.commit.interval.ms消费者offset提交到zookeeper的频率（以毫秒为单位）（0.9之后就默认存储再broke中了）<br />auto.commit.enable must be set to false when using this API.使用此API时 auto.commit.enable必须设置为false，如果enable.auto.commit设置为true，则消费者偏移量自动提交给Kafka的频率（以毫秒为单位）。<br />auto.offset.reset	largest	如果ZooKeeper中没有初始偏移量，或偏移值超出范围，<br />该怎么办？<br />最小：自动将偏移重置为最小偏移<br />最大：自动将偏移重置为最大偏移<br />* 其他任何事情：抛出异常消费者</p>
<p>参数<br />partition (integer)<br />Partition ID<br />offset (integer)<br />Offset</p>
<p><br />2)/* Inherited methods */<br />public string RdKafka\Topic::getName ( void )</p>
<p>RdKafka类<br />(PECL rdkafka &gt;= 0.9.1)<br />This is the base class for low-level clients: RdKafka\Consumer, RdKafka\Producer. This class can not be instanciated directly, use one of the sub classes instead.<br />这是低级消费者客户端的基类：RdKafka\Consumer，RdKafka\Producer。不能直接实例化这个类，而是使用其中一个子类。</p>
<p>1)public integer RdKafka::addBrokers ( string $broker_list )<br />将一个或多个代理添加到Kafka句柄的初始引导代理列表中。<br />当rdkafka通过查询代理元数据连接到代理时，将自动发现其他代理。<br />如果代理名称解析为多个地址(可能是地址家族)，则所有代理名称都将以循环方式用于连接尝试。<br />返回值<br />Returns the number of brokers successfully added.成功添加的代理个数</p>
<p>代理还可以使用metadata.broker.list或bootstrap.server配置属性(首选方法)进行定义。</p>
<p>$kafka-&gt;addBrokers("broker1:10000,broker2");</p>
<p>$kafka-&gt;addBrokers("SSL://broker3:9000,ssl://broker2");</p>
<p>2)public RdKafka\Metadata RdKafka::getMetadata ( bool $all_topics , RdKafka\Topic $only_topic = NULL , int $timeout_ms ) <br />Request Metadata from broker  向代理请求元数据<br />上面有一个</p>
<p>3)public integer RdKafka::getOutQLen ( void )<br />返回当前的输出队列长度。Out队列包含等待发送给代理的消息，或代理知道的消息。</p>
<p>3)public RdKafka\Queue RdKafka::newQueue ( void )<br />创建一个新的消息队列实例<br />Return Values<br />Returns a RdKafka\Queue.</p>
<p>4)public RdKafka\Topic RdKafka::newTopic ( string $topic_name [, RdKafka\TopicConf $topic_conf = NULL ] )<br />Creates a new topic instance for topic_name.为Topic_Name创建一个新的主题实例。<br />Returns a RdKafka\Topic (more specifically, either a RdKafka\ConsumerTopic or a RdKafka\ProducerTopic).</p>
<p>为具有不同配置的同一主题名称创建两个主题实例没有任何效果。每个主题实例都将使用第一个实例的配置。<br />$conf = new RdKafka\TopicConf();<br />$conf-&gt;set("...", "...");</p>
<p>$topic = $kafka-&gt;newTopic("myTopic", $conf);</p>
<p><br />4)public void RdKafka::poll ( integer $timeout_ms )<br />对于事件的轮询，导致调用应用程序提供的回调<br />使用rdKafka子类的应用程序应该确保定期调用poll()，以便为等待调用的任何排队回调服务。</p>
<p>Events:<br />Delivery report callbacks RdKafka\Conf::setDrMsgCb() [producer]<br />Error callbacks (RdKafka\Conf::setErrorCb())<br />Stats callbacks (RdKafka\Conf::setStatsCb())<br />Throttle callbacks (RdKafka\Conf::setThrottleCb())</p>
<p>Parameters<br />timeout_ms (integer)<br />Specifies the maximum amount of time (in milliseconds) that the call will block waiting for events. For non-blocking calls, provide 0 as timeout_ms. To wait indefinately for an event, provide -1.<br />指定调用将阻止等待事件的最大时间(以毫秒为单位)。对于非阻塞调用，提供0作为timeout_ms。若要不确定地等待某个事件，请提供-1。</p>
<p>Return Values<br />Returns the number of events served.返回服务的事件数</p>
<p>5)public void RdKafka::setLogLevel ( integer $level )<br />指定内部Kafka日志记录和调试产生的最大日志记录级别。如果设置了&ldquo;DEBUG&rdquo;配置属性，该级别将自动调整为LOG_DEBUG。</p>
<p>Parameters<br />level (integer)<br />Log level. Can take any LOG_* constant (see the syslog function).日志级别。可以接受任何log_*常量(请参阅syslog函数)。</p>
<p>&nbsp;</p>
<p>RdKafka\Consumer 类<br />This is the low-level Kafka consumer. It can be used with Kafka &gt;= 0.8.<br />低级消费者<br />1)public RdKafka\Consumer::__construct ([ RdKafka\Conf $conf = NULL ] )<br />Parameters<br />conf (RdKafka\Conf)<br />An optional RdKafka\Conf instance.</p>
<p>此类只有继承(低级消费者基类RdKafka)的以下几个方法<br />RdKafka\Consumer extends RdKafka {<br />/* Methods */<br />/* Inherited methods */<br />public integer RdKafka::addBrokers ( string $broker_list )<br />public RdKafka\Metadata RdKafka::getMetadata ( bool $all_topics , RdKafka\Topic $only_topic = NULL , int $timeout_ms )<br />public integer RdKafka::getOutQLen ( void )<br />public RdKafka\Queue RdKafka::newQueue ( void )<br />public RdKafka\Topic RdKafka::newTopic ( string $topic_name [, RdKafka\TopicConf $topic_conf = NULL ] )<br />public void RdKafka::poll ( integer $timeout_ms )<br />public void RdKafka::setLogLevel ( integer $level )<br />}<br />RdKafka\Producer类<br />(PECL rdkafka &gt;= 0.9.1)</p>
<p>1)public RdKafka\Producer::__construct ([ RdKafka\Conf $conf = NULL ] )<br />Parameters<br />conf (RdKafka\Conf)<br />An optional RdKafka\Conf instance.</p>
<p>RdKafka\Producer extends RdKafka {<br />/* Methods */<br />/* Inherited methods */<br />public integer RdKafka::addBrokers ( string $broker_list )<br />public RdKafka\Metadata RdKafka::getMetadata ( bool $all_topics , RdKafka\Topic $only_topic = NULL , int $timeout_ms )<br />public integer RdKafka::getOutQLen ( void )<br />public RdKafka\Queue RdKafka::newQueue ( void )<br />public RdKafka\Topic RdKafka::newTopic ( string $topic_name [, RdKafka\TopicConf $topic_conf = NULL ] )<br />public void RdKafka::poll ( integer $timeout_ms )<br />public void RdKafka::setLogLevel ( integer $level )<br />}</p>
<p>RdKafka\Topic类<br />(PECL rdkafka &gt;= 0.9.1)</p>
<p>1)public string RdKafka\Topic::getName ( void )<br />Returns the topic name.返回主题名称</p>
<p>RdKafka\ConsumerTopic 类<br />(PECL rdkafka &gt;= 0.9.1)</p>
<p>当使用RdKafka\Consumer时，该类表示一个主题。不能直接实例化它，应该使用RdKafka\Consumer：newTopic()。</p>
<p>1)public RdKafka\Message RdKafka\ConsumerTopic::consume ( integer $partition , integer $timeout_ms )<br />消费-使用来自分区的单个消息<br />消费者之前必须使用 RdKafka\ConsumerTopic::consumeStart().<br />必须检查返回消息的ERR属性是否存在错误。<br />Err属性等于RD_Kafka_RESP_ERR_PARY_EOF，表示已到达分区的结束，通常不应将其视为错误。应用程序应该处理这种情况(例如，忽略)。<br />Parameters<br />partition (integer)<br />The partition to consume<br />timeout_ms<br />The maximum amount of time to wait for a message to be received.</p>
<p>Returns a RdKafka\Message or NULL on timeout. 正常返回RdKafka\Message，超时返回NULL。</p>
<p>2)public void RdKafka\ConsumerTopic::consumeQueueStart ( integer $partition , integer $offset , RdKafka\Queue $queue )<br />与RdKafka\ConsumerTopic::consumerTopic()相同，但将传入消息重新路由到提供的队列。应用程序必须使用一个RdKafka\Queue::consumer*()函数来接收获取的消息。<br />参数<br />partition (integer)<br />Partition ID<br />offset (integer)<br />Offset<br />queue (RdKafka\Queue)<br />A RdKafka\Queue instance</p>
<p>3)public void RdKafka\ConsumerTopic::consumeStart ( integer $partition , integer $offset )<br />开始在偏移量处使用分区的消息(请参阅参数中允许的值)。</p>
<p>librdkafka将尝试通过反复从代理获取批消息，直到达到阈值，从而将queued.min.messages (config属性)消息保留在本地队列中。<br />应用程序应该使用RdKafka\ConsumerTopic::consumeStart()方法来使用本地队列中的消息，每个Kafka消息都表示为RdKafka\Message对象。<br />对于同一个主题和分区，不能多次调用RdKafka\ConsumerTopic::consumeStart()。在没有停止消费的情况下，先使用RdKafka\ConsumerTopic::consumeStop()停止消费后再开始消费。</p>
<p>Parameters<br />partition (integer)<br />Partition ID <br />offset (integer)<br />Can be either a proper offset (0..N), or one the the special offset:<br />可以是正常的偏移量(0.N)，也可以是特殊的偏移量：<br />RD_KAFKA_OFFSET_BEGINNING<br />RD_KAFKA_OFFSET_END<br />RD_KAFKA_OFFSET_STORED<br />The return value of rd_kafka_offset_tail() <br />示例：<br />$partition = 123;</p>
<p>// consume from the end<br />$topic-&gt;consumeStart($partition, RD_KAFKA_OFFSET_END);</p>
<p>// consume from the stored offset<br />$topic-&gt;consumeStart($partition, RD_KAFKA_OFFSET_STORED);</p>
<p>// consume 200 messages from the end<br />$topic-&gt;consumeStart($partition, rd_kafka_offset_tail(200));</p>
<p>4)public void RdKafka\ConsumerTopic::consumeStop ( integer $partition )<br />Stop consuming messages from partition停止使用来自分区的消息<br />停止使用分区消息，清除当前本地队列中的所有消息。</p>
<p>5)public void RdKafka\ConsumerTopic::offsetStore ( integer $partition , integer $offset )<br />store offset存储offset<br />Parameters<br />partition (integer)<br />Partition ID<br />offset (integer)<br />Offset</p>
<p>RdKafka\ProducerTopic类<br />(PECL rdkafka &gt;= 0.9.1)<br />当使用RdKafka\Producer时，该类表示一个主题。不能直接实例化它，应该使用RdKafka\Producer::newTopic().</p>
<p>RdKafka\ProducerTopic extends RdKafka\Topic {<br />/* Methods */<br />public void produce ( integer $partition , integer $msgflags , string $payload [, string $key = NULL ] )<br />/* Inherited methods */<br />public string RdKafka\Topic::getName ( void )<br />}</p>
<p>1)public void RdKafka\ProducerTopic::produce ( integer $partition , integer $msgflags , string $payload [, string $key = NULL ] )<br />生成并向代理发送一条消息。这是一个异步和非阻塞的。<br />Parameters<br />partition (integer)<br />Can be either RD_KAFKA_PARTITION_UA (unassigned) for automatic partitioning using the topic's partitioner function (see RdKafka\TopicConf::setPartitioner(), or a fixed partition (0..N).<br />msgflags (integer)<br />可以是RD_Kafka_PARID_UA(未分配的)，用于使用主题的分区函数(请参见RdKafka\TopicConf::setPartitioner()，也可以是固定的分区(0.N)。<br />msgflags (integer)<br />Must be 0<br />payload (string)<br />Payload string<br />key (string)<br />Optional message key, if non-NULL it will be passed to the topic partitioner as well as be sent with the message to the broker and passed on to the consumer.<br />可选消息键，如果非空，则将其传递给主题分区程序，并与消息一起发送给代理并传递给使用者。</p>
<p>$message = [<br />    'type' =&gt; 'account-created',<br />    'id' =&gt; $accountId,<br />    'date' =&gt; date(DATE_W3C),<br />];<br />$payload = json_encode($message);<br />$topic-&gt;produce(RD_KAFKA_PARTITION_UA, 0, $payload, $accountId);with the message to the broker and passed on to the consumer.</p>
<p>RdKafka\Queuel类<br />(PECL rdkafka &gt;= 0.9.1)<br />1)public RdKafka\Message RdKafka\Queue::consume ( string $timeout_ms )<br />使用一条消息<br />Parameters<br />timeout_ms<br />The maximum amount of time to wait for a message to be received.<br />Return Values<br />Returns a RdKafka\Message or NULL on timeout.</p>
<p>RdKafka\Message 类<br />(PECL rdkafka &gt;= 0.9.1)<br />此对象表示单个已消费或生产的消息或事件(设置了$err)。<br />This object represents either a single consumed or produced message, or an event ($err is set).<br />An application must check RdKafka\Message::err to see if the object is a proper message (error is RD_KAFKA_RESP_ERR_NO_ERROR) or an error event.</p>
<p>RdKafka\Message {<br />/* Properties */<br />public $err ; //Error code<br />public $topic_name ; <br />public $partition ;<br />public $payload ;<br />public $key ;<br />public $offset ;<br />/* Methods */<br />public string errstr ( void )<br />}</p>
<p>1)public string RdKafka\Message::errstr ( void )<br />这是一种方便的方法，将错误作为字符串返回<br />Return Values<br />The error as a string<br />if ($message-&gt;err) {<br />    echo $message-&gt;errstr(), "\n";<br />}</p>
<p><br />RdKafka\Conf 类<br />(PECL rdkafka &gt;= 0.9.1)<br />This class holds configuration for consumers and producers.<br />A list of available properties can be found on the &raquo;librdkafka repository. Note that available configuration properties and default values may change depending on the librdkafka version.<br />该类包含使用者和生产者的配置<br />请注意，可用的配置属性和默认值可能会根据librdkafka 版本而改变。</p>
<p>RdKafka\Conf {<br />/* Methods */<br />public void dump ( void )<br />public void set ( string $name , string $value )<br />public void setDefaultTopicConf ( RdKafka\TopicConf $topic_conf )<br />public void setDrMsgCb ( callable $callback )<br />public void setErrorCb ( callable $callback )<br />public void setRebalanceCb ( callable $callback )<br />}</p>
<p>1)public void RdKafka\Conf::dump ( void )<br />Dumps the configuration properties and values to an array.<br />转储配置属性和值到数组<br />Return Values<br />Returns an array with configuration properties as keys, and configuration values as values.</p>
<p>2)public void RdKafka\Conf::set ( string $name , string $value )<br />Set configuration property name to value.<br />设置配置属性 属性名=&gt;属性值</p>
<p>3)public void RdKafka\Conf::setDefaultTopicConf ( RdKafka\TopicConf $topic_conf )<br />设置用于自动订阅主题的默认主题配置。可以与RdKafka\KafkaConsumer::subscribe()或者RdKafka\KafkaConsumer::assign()一起使用<br />Sets the default topic configuration to use for for automatically subscribed topics. This can be used along with RdKafka\KafkaConsumer::subscribe() or RdKafka\KafkaConsumer::assign().</p>
<p>4)public void RdKafka\Conf::setDrMsgCb ( callable $callback )<br />设置传递报告回调,对于RdKafka\ProducerTopic::Producer()接受的每条消息，将调用一次传递报告回调，并将ERR设置为指示生产请求的结果。</p>
<p>当消息成功地生成时，或者如果librdkafka 遇到永久故障，或者临时错误的重试计数器已经耗尽，就会调用回调。</p>
<p>应用程序必须定期调用rdKafka::poll()，以便为排队的传递报告回调服务。</p>
<p>Parameters<br />callback (callable)<br />A callable with the following signature:<br />&lt;?php<br />/**<br /> * @param RdKafka\Kafka $kafka<br /> * @param RdKafka\Message $message<br /> */<br />function (RdKafka\Kafka $kafka, RdKafka\Message $message);</p>
<p>$conf-&gt;setDrMsgCb(function ($kafka, $message) {<br />    if ($message-&gt;err) {<br />        // message permanently failed to be delivered<br />    } else {<br />        // message successfully delivered<br />    }<br />});</p>
<p><br />5)public void RdKafka\Conf::setErrorCb ( callable $callback )</p>
<p>设置错误回调。librdkafka 使用错误回调将ciritcal错误信号发送回应用程序。</p>
<p>Parameters<br />callback (callable)<br />A callable with the following signature:<br />&lt;?php<br />/**<br /> * @param object $kafka<br /> * @param int $err<br /> * @param string $reason<br /> */<br />function ($kafka, $err, $reason);</p>
<p>&lt;?php<br />$conf-&gt;setErrorCb(function ($kafka, $err, $reason) {<br />    printf("Kafka error: %s (reason: %s)\n", rd_kafka_err2str($err), $reason);<br />});<br />?&gt;</p>
<p><br />6)public void RdKafka\Conf::setRebalanceCb ( callable $callback )</p>
<p>Set rebalance callback for use with coordinated consumer group balancing.<br />设置&ldquo;再平衡回调&rdquo;，以便与协调的消费者组 平衡一起使用。</p>
<p>Registering a rebalance_cb turns off librdkafka's automatic partition assignment/revocation and instead delegates that responsibility to the application's rebalance_cb.<br />注册一个reBalance_cb会关闭librdkafka的自动分区分配/撤销，而是将这一责任委托给应用程序的reBalance_cb。</p>
<p>The rebalance callback is responsible for updating librdkafka's assignment set based on the two events RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONSand RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS but should also be able to handle arbitrary rebalancing failures where err is neither of those.<br />重新平衡回调负责根据这两个事件RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS和RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS更新librdkafka的分配集，但也应该能够再平衡处理任意的不止这些的失败。</p>
<p>In this latter case (arbitrary error), the application must $kafka-&gt;assign(NULL) to synchronize （同步）state.<br />后一种情况 必须使用assign去同步状态</p>
<p>在没有重新平衡回调的情况下，这是由librdkafka自动完成的，但是注册一个重新平衡回调会使应用程序在执行其他操作时具有灵活性，同时还可以执行排序/撤销操作（assinging/revocation）。例如从另一个位置获取偏移量(在赋值时)或手动提交偏移量(在REVOKE上)。</p>
<p>Parameters<br />callback (callable)<br />A callable with the following signature:<br />&lt;?php<br />/**<br /> * @param RdKafka\KafkaConsumer $kafka<br /> * @param int $err<br /> * @param array $partitions<br /> */<br />function (RdKafka\KafkaConsumer $kafka, $err, $partitions);<br />ERR参数被设置为RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS或RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS(或意外错误)。<br />partitions参数是RdKafka\TopicPartition数组，表示分配或撤销的完整分区集。</p>
<p>&lt;?php<br />$conf-&gt;setRebalanceCb(function (RdKafka\KafkaConsumer $kafka, $err, array $partitions = null) {<br />    switch ($err) {<br />        case RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS:<br />            // application may load offets from arbitrary external<br />            // storage here and update partitions<br />            $kafka-&gt;assign($partitions);<br />            break;</p>
<p>         case RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS:<br />             if ($manual_commits) {<br />                 // Optional explicit manual commit<br />                 $kafka-&gt;commit($partitions);<br />             }<br />             $kafka-&gt;assign(NULL);<br />             break;</p>
<p>         default:<br />            handle_unlikely_error($err);<br />            $kafka-&gt;assign(NULL); // sync state同步状态<br />            break;<br />    }<br />}<br />?&gt;</p>
<p>RdKafka\TopicConf类<br />(PECL rdkafka &gt;= 0.9.1)</p>
<p>该类保存主题topic实例的配置。<br />A list of available properties can be found on the &raquo;&ensp;librdkafka repository. Note that available configuration properties and default values may change depending on the librdkafka version.<br />注意配置属性依赖版本 ， 可以从librdkafka仓库中查看详细配置</p>
<p>RdKafka\TopicConf {<br />/* Methods */<br />public void dump ( void )<br />public void set ( void )<br />public void setPartitioner ( integer $partitioner )<br />}</p>
<p>1)public void RdKafka\TopicConf::dump ( void )<br />将配置属性和值转储到数组。<br />返回一个数组，其中配置属性作为键，配置值作为值。</p>
<p>2)public void RdKafka\TopicConf::set ( void )<br />Set configuration property name to value.</p>
<p>3)public void RdKafka\TopicConf::setPartitioner ( integer $partitioner )<br />将分区器设置为根据keys将消息路由到分区。<br />Parameters<br />partitioner (integer)<br />Must be one of the RD_KAFKA_MSG_PARTITIONER_* constants.<br />必须是RD_Kafka_MSG_Partiator_*常量之一。</p>
<p>RdKafka\Exception类<br />(PECL rdkafka &gt;= 0.9.1)</p>
<p>RdKafka Exception.异常类<br />RdKafka\Exception extends Exception {<br />/* Inherited properties */<br />protected string $message ;<br />protected int $code ;<br />protected string $file ;<br />protected int $line ;<br />/* Methods */<br />/* Inherited methods */<br />final public string Exception::getMessage ( void )<br />final public Exception Exception::getPrevious ( void )<br />final public mixed Exception::getCode ( void )<br />final public string Exception::getFile ( void )<br />final public int Exception::getLine ( void )<br />final public array Exception::getTrace ( void )<br />final public string Exception::getTraceAsString ( void )<br />public string Exception::__toString ( void )<br />final private void Exception::__clone ( void )<br />}</p>
<p>RdKafka\TopicPartition类<br />(PECL rdkafka &gt;= 1.0.0, librdkafka &gt;= 0.9)</p>
<p>Topic+Partition 主题加分区<br />RdKafka\TopicPartition {<br />/* Methods */<br />public integer getOffset ( void )<br />public integer getPartition ( void )<br />public string getTopic ( void )<br />public void setOffset ( string $offset )<br />public ReturnType setPartition ( string $partition )<br />public ReturnType setTopic ( string $topic_name )<br />}</p>
<p>1)public RdKafka\TopicPartition::__construct ( string $topic , integer $partition [, integer $offset = NULL ] )<br />Parameters<br />topic (string)<br />Topic name<br />partition (integer)<br />Partition ID<br />offset (integer)<br />Offset<br />&lt;?php<br />new RdKafka\TopicPartition("myTopic", 1);<br />?&gt;</p>
<p>2)public integer RdKafka\TopicPartition::getOffset ( void )<br />获取偏移量</p>
<p>3)public integer RdKafka\TopicPartition::getPartition ( void )<br />Gets the partition ID. 得到分区id</p>
<p>4)public string RdKafka\TopicPartition::getTopic ( void )<br />Gets the topic name. 得到主题</p>
<p>5)public void RdKafka\TopicPartition::setOffset ( string $offset )<br />Sets the offset. 设置偏移量</p>
<p>6)public ReturnType RdKafka\TopicPartition::setPartition ( string $partition )<br />Sets the partition ID.</p>
<p>7)public ReturnType RdKafka\TopicPartition::setTopic ( string $topic_name )<br />Sets the topic name.</p>
<p>RdKafka\Metadata类<br />(PECL rdkafka &gt;= 0.9.1)<br />The Metadata class represents broker information. Metadata instances are returned by RdKafka::getMetadata() and RdKafka\KafkaConsumer::getMetadata().<br />元数据类表示代理信息。元数据实例由RdKafka::getMetadata() 和RdKafka\KafkaConsumer::getMetadata()返回。</p>
<p>RdKafka\Metadata {<br />/* Methods */<br />public RdKafka\Metadata\Collection getBrokers ( void )<br />public int getOrigBrokerId ( void )<br />public string getOrigBrokerName ( void )<br />public RdKafka\Metadata\Collection getTopics ( void )<br />}</p>
<p>1)public RdKafka\Metadata\Collection RdKafka\Metadata::getBrokers ( void )<br />Get broker list<br />Returns a RdKafka\Metadata\Collection of RdKafka\Metadata\Broker<br />2)public int RdKafka\Metadata::getOrigBrokerId ( void )<br />获取源自此元数据的代理id</p>
<p>3)public string RdKafka\Metadata::getOrigBrokerName ( void )<br />获取源自此元数据的代理名称。</p>
<p>4)public RdKafka\Metadata\Collection RdKafka\Metadata::getTopics ( void )<br />获取主题列表。根据元数据的请求方式，这可能包含单个主题、本地已知主题列表或所有集群主题。<br />Returns a RdKafka\Metadata\Collection of RdKafka\Metadata\Topic</p>
<p>RdKafka\Metadata\Collection类<br />(PECL rdkafka &gt;= 0.9.1)</p>
<p>集合类用作元数据项的集合。它实现了 Countable and Iterable，因此它可以与count()和foreach一起使用</p>
<p>RdKafka\Metadata\Collection implements Countable , Iterator {<br />/* Methods */<br />public int count ( void )<br />public mixed current ( void )<br />public scalar key ( void )<br />public void next ( void )<br />public void rewind ( void )<br />public boolean valid ( void )<br />}</p>
<p>1)public int RdKafka\Metadata\Collection::count ( void )<br />Returns the number of elements as integer 返回元素数量</p>
<p>2)public mixed RdKafka\Metadata\Collection::current ( void )<br />Gets the current value. 获取到当前的值<br />返回值：<br />The current value if it is valid or NULL otherwise.</p>
<p>3)public scalar RdKafka\Metadata\Collection::key ( void )<br />Get the current key.<br />返回值：<br />The current key if it is valid or NULL otherwise.</p>
<p>4)public void RdKafka\Metadata\Collection::next ( void )<br />移到下一个元素。<br />5)public void RdKafka\Metadata\Collection::rewind ( void )<br />将Iterator倒转到第一个元素</p>
<p>6)public boolean RdKafka\Metadata\Collection::valid ( void )<br />Checks if current position is valid 检查当前位置是否有效<br />Returns TRUE on success or FALSE on failure.</p>
<p>Predefined Constants<br />The constants below are defined by this extension, and will only be available when the extension has either been compiled into PHP or dynamically loaded at runtime.<br />下面的常量是由这个扩展定义的，并且只有当扩展编译到PHP或在运行时动态加载时才可用。<br />RD_KAFKA_CONSUMER (integer)<br />RD_KAFKA_OFFSET_BEGINNING (integer)<br />Start consuming from beginning of kafka partition queue: oldest msg.<br />RD_KAFKA_OFFSET_END (integer)<br />Start consuming from end of kafka partition queue: next msg.<br />RD_KAFKA_OFFSET_STORED (integer)<br />Start consuming from offset retrieved from offset store.<br />RD_KAFKA_PARTITION_UA (integer)<br />The unassigned partition is used by the producer API for messages that should be partitioned using the configured or default partitioner.<br />RD_KAFKA_PRODUCER (integer)<br />RD_KAFKA_VERSION (integer)<br />RD_KAFKA_RESP_ERR__BEGIN (integer)<br />RD_KAFKA_RESP_ERR__BAD_MSG (integer)<br />Local: Bad message format<br />RD_KAFKA_RESP_ERR__BAD_COMPRESSION (integer)<br />Local: Invalid compressed data<br />RD_KAFKA_RESP_ERR__DESTROY (integer)<br />Local: Broker handle destroyed<br />RD_KAFKA_RESP_ERR__FAIL (integer)<br />Local: Communication failure with broker<br />RD_KAFKA_RESP_ERR__TRANSPORT (integer)<br />Local: Broker transport failure<br />RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE (integer)<br />Local: Critical system resource failure<br />RD_KAFKA_RESP_ERR__RESOLVE (integer)<br />Local: Host resolution failure<br />RD_KAFKA_RESP_ERR__MSG_TIMED_OUT (integer)<br />Local: Message timed out<br />RD_KAFKA_RESP_ERR__PARTITION_EOF (integer)<br />Broker: No more messages<br />RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION (integer)<br />Local: Unknown partition<br />RD_KAFKA_RESP_ERR__FS (integer)<br />Local: File or filesystem error<br />RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC (integer)<br />Local: Unknown topic<br />RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN (integer)<br />Local: All broker connections are down<br />RD_KAFKA_RESP_ERR__INVALID_ARG (integer)<br />Local: Invalid argument or configuration<br />RD_KAFKA_RESP_ERR__TIMED_OUT (integer)<br />Local: Timed out<br />RD_KAFKA_RESP_ERR__QUEUE_FULL (integer)<br />Local: Queue full<br />RD_KAFKA_RESP_ERR__ISR_INSUFF (integer)<br />Local: ISR count insufficient<br />RD_KAFKA_RESP_ERR__NODE_UPDATE (integer)<br />Local: Broker node update<br />RD_KAFKA_RESP_ERR__SSL (integer)<br />Local: SSL error<br />RD_KAFKA_RESP_ERR__WAIT_COORD (integer)<br />Local: Waiting for coordinator<br />RD_KAFKA_RESP_ERR__UNKNOWN_GROUP (integer)<br />Local: Unknown group<br />RD_KAFKA_RESP_ERR__IN_PROGRESS (integer)<br />Local: Operation in progress<br />RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS (integer)<br />Local: Previous operation in progress<br />RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION (integer)<br />Local: Existing subscription<br />RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS (integer)<br />Local: Assign partitions<br />RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS (integer)<br />Local: Revoke partitions<br />RD_KAFKA_RESP_ERR__CONFLICT (integer)<br />Local: Conflicting use<br />RD_KAFKA_RESP_ERR__STATE (integer)<br />Local: Erroneous state<br />RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL (integer)<br />Local: Unknown protocol<br />RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED (integer)<br />Local: Not implemented<br />RD_KAFKA_RESP_ERR__AUTHENTICATION (integer)<br />Local: Authentication failure<br />RD_KAFKA_RESP_ERR__NO_OFFSET (integer)<br />Local: No offset stored<br />RD_KAFKA_RESP_ERR__END (integer)<br />RD_KAFKA_RESP_ERR_UNKNOWN (integer)<br />Unknown broker error<br />RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE (integer)<br />Broker: Offset out of range<br />RD_KAFKA_RESP_ERR_INVALID_MSG (integer)<br />Broker: Invalid message<br />RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART (integer)<br />Broker: Unknown topic or partition<br />RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE (integer)<br />Broker: Invalid message size<br />RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE (integer)<br />Broker: Leader not available<br />RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION (integer)<br />Broker: Not leader for partition<br />RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT (integer)<br />Broker: Request timed out<br />RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE (integer)<br />Broker: Broker not available<br />RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE (integer)<br />Broker: Replica not available<br />RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE (integer)<br />Broker: Message size too large<br />RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH (integer)<br />Broker: StaleControllerEpochCode<br />RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE (integer)<br />Broker: Offset metadata string too large<br />RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION (integer)<br />Broker: Broker disconnected before response received<br />RD_KAFKA_RESP_ERR_GROUP_LOAD_IN_PROGRESS (integer)<br />Broker: Group coordinator load in progress<br />RD_KAFKA_RESP_ERR_GROUP_COORDINATOR_NOT_AVAILABLE (integer)<br />Broker: Group coordinator not available<br />RD_KAFKA_RESP_ERR_NOT_COORDINATOR_FOR_GROUP (integer)<br />Broker: Not coordinator for group<br />RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION (integer)<br />Broker: Invalid topic<br />RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE (integer)<br />Broker: Message batch larger than configured server segment size<br />RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS (integer)<br />Broker: Not enough in-sync replicas<br />RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND (integer)<br />Broker: Message(s) written to insufficient number of in-sync replicas<br />RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS (integer)<br />Broker: Invalid required acks value<br />RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION (integer)<br />Broker: Specified group generation id is not valid<br />RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL (integer)<br />Broker: Inconsistent group protocol<br />RD_KAFKA_RESP_ERR_INVALID_GROUP_ID (integer)<br />Broker: Invalid group.id<br />RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID (integer)<br />Broker: Unknown member<br />RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT (integer)<br />Broker: Invalid session timeout<br />RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS (integer)<br />Broker: Group rebalance in progress<br />RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE (integer)<br />Broker: Commit offset data size is not valid<br />RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED (integer)<br />Broker: Topic authorization failed<br />RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED (integer)<br />Broker: Group authorization failed<br />RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED (integer)<br />Broker: Cluster authorization failed<br />RD_KAFKA_CONF_UNKNOWN (integer)<br />RD_KAFKA_CONF_INVALID (integer)<br />RD_KAFKA_CONF_OK (integer)<br />RD_KAFKA_MSG_PARTITIONER_RANDOM (integer)<br />The random partitioner. This was the default partitioner in librdkafka 0.8. Assigns partition randomly.<br />RD_KAFKA_MSG_PARTITIONER_CONSISTENT (integer)<br />The consistent partitioner. Uses consistent hashing to map identical keys onto identical partitions. Uses CRC32 as hashing function. Messages with no key or empty key are always assigned to the same partition.<br />RD_KAFKA_LOG_PRINT (integer)<br />The print logger. Prints messages to stderr.<br />RD_KAFKA_LOG_SYSLOG (integer)<br />The syslog logger. Sends messages to syslog.<br />RD_KAFKA_LOG_SYSLOG_PRINT (integer)<br />The syslog-print partitioner. Sends messages to syslog and prints them to stderr.</p>
<p>&nbsp;</p>

</div></div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>