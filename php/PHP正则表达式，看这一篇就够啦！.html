<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修PHP正则表达式，看这一篇就够啦！' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>PHP正则表达式，看这一篇就够啦！</center></div><div class='banquan'>原文出处:本文由博客园博主Johnson木木提供。<br/>
原文连接:https://www.cnblogs.com/Johnson-lin/p/10875388.html</div><br>
    <h1 id="前言">前言</h1>
<p>不知道你们有没有这个感觉，看正则表达式就像看天文数字一样，什么电话号码、邮箱的正则表达式，上网复制一下粘贴下来就搞定了。完全不知道这写的是什么玩意。后来我自己也想学一下，因为感觉用处还是挺大的。看了看视频，额...真**简单。这里的话如果想看视频学习的话我推荐一下慕课网这门<a href="https://www.imooc.com/learn/350">鬼斧神工之正则表达式</a>课程，上手真的太快了。好了，废话不多说，开始搞事情。</p>
<h1 id="基本语法">基本语法</h1>
<h2 id="界定符">界定符：</h2>
<p>标识一个正则表达式的开始和结束，用'/'或'#'或'{ }',因为语法'{ }'也可能是正则表达式的运算符，为了避免混淆，所以不建议使用。建议的用法如下：</p>
<pre><code><code>$pattern = &#39;/[0-9]/&#39;;  //我喜欢这个，看起来比较简洁 
$pattern = &#39;#[0-9]#&#39;;</code></code></pre>
<h2 id="原子">原子：</h2>
<blockquote>
<p><strong>可见原子</strong>：Unicode编码表中可用键盘输出后肉眼可见的字符，例如：标点 ; . / ? 或者英文字母，汉字等等可见字符<br />
<strong>不可见原子</strong>：Unicode编码表中可用键盘输出后肉眼不可见的字符，例如：换行符 \n，Tab制表符\t, 空格等等，<br />
一般只用这三个（换行符一般和其他字符一起匹配，因为只有换行符是匹配不到的）<br />
小提示：匹配运算符前面需要加<code>'\'</code> 例如：'+' 号，匹配的话需要写出 <code>'\+'</code></p>
</blockquote>
<h2 id="元字符">元字符</h2>
<p><strong>原子的筛选方式：</strong></p>
<blockquote>
<p>| 匹配两个或者多个分支选择<br />
[] 匹配方括号中的任意一个原子<br />
[^] 匹配除方括号中的原子之外的任意字符；<br />
例子：Duang|duang 或者 [Dd]uang 都可以匹配到Duang和duang<br />
区间写法：[a-z]匹配a到z的字符, [0-9]匹配0到9的字符。也可以[a-z0-9]<br />
. 匹配除换行符之外的任意字符<br />
\d 匹配任意一个十进制数字，即{0-9]<br />
\D 匹配任意一个非十进制数字[^0-9] 相当于[^\d]<br />
\s 匹配一个不可见的原子，即[\f\n\r\t\v]<br />
\S 匹配一个可见的原子，即[^\f\n\r\t\v],相当于[^\s]z<br />
\w 匹配任意一个数字、字母或下划线，即[0-9a-zA-Z_]<br />
\W 匹配任意一个非数字、字母或下划线，[^0-9a-zA-Z_]，相当于[^\w]</p>
</blockquote>
<h2 id="量词">量词</h2>
<blockquote>
<p>{n} 表示其前面的原子刚好出现了n次。<br />
[n] 表示其前面的原子最少出现n次<br />
{n,m} 最少出现n次，最多出现m次<br />
<code>*</code> 匹配0次、一次或者多次，即{0,}<br />
<code>+</code> 匹配一次或多次,即{1,}<br />
<code>?</code> 匹配0或1次，即{0,1}</p>
</blockquote>
<h2 id="边界控制">边界控制</h2>
<blockquote>
<p>^ 匹配字符串开始的位置<br />
$ 匹配字符串结尾的位置<br />
例：^John 可以匹配到:John 但是匹配不到:123John,因为规定了字符串以John开头</p>
</blockquote>
<h2 id="模式单元">模式单元</h2>
<blockquote>
<p>{} 匹配其中的整体为一个原子</p>
</blockquote>
<p><br><br></p>
<h1 id="修正模式">修正模式</h1>
<h2 id="贪婪匹配">贪婪匹配</h2>
<blockquote>
<p>匹配结果存在歧义时取其长（默认）</p>
</blockquote>
<h2 id="懒惰匹配">懒惰匹配</h2>
<blockquote>
<p>匹配结果存在歧义时取其短，只需在正则表达式的后面'/'加上'U'，例如'/[0-9]/U';<br />
例子：</p>
</blockquote>
<pre><code><code>$subject = &quot;test__123123123&quot;;
preg_match(&#39;/test.+123/&#39;, $subject, $matches); //贪婪模式  
var_dump($matches);
preg_match(&#39;/test.+123/U&#39;, $subject, $matches); //懒惰模式
var_dump($matches);</code></code></pre>
<h2 id="常见的修正模式">常见的修正模式：</h2>
<blockquote>
<p>U 懒惰匹配<br />
i 忽略英文字母的大小写<br />
x 忽略正则表达式的空白符<br />
s 让元字符'.' 匹配包括换行符在内的所有字符</p>
</blockquote>
<p><br><br></p>
<h1 id="常用函数">常用函数</h1>
<h2 id="preg_match">preg_match</h2>
<p>执行匹配正则表达式</p>
<blockquote>
<p>preg_match ( string $pattern , string $subject [, array &amp;$matches [, int $flags = 0 [, int $offset = 0 ]]] ) : int</p>
<ul>
<li>pattern: 要搜索的模式，字符串类型。</li>
<li>subject：输入字符串。</li>
<li>match： 如果提供了参数matches，它将被填充为搜索结果,数据结构为一维数组。</li>
<li>flags: 可以设置为PREG_OFFSET_CAPTURE，使用搜索结果的第0个元素为匹配的字符串，第1个元素为对应的偏移量（位置）</li>
<li>offset: 搜索从目标字符串的起始位置开始匹配。</li>
</ul>
</blockquote>
<blockquote>
<p>返回值：匹配次数<br />
类似函数<code>preg_match_all</code>，参数与<code>preg_match</code>一致<br />
区别：</p>
<ul>
<li><code>preg_match</code>：只匹配一次，搜索结构match的数据结果为一维数组</li>
<li><code>preg_match_all</code>：匹配全部，搜索结果match的数据结构为二维数组。</li>
</ul>
</blockquote>
<h2 id="preg_replace">preg_replace</h2>
<p>执行一个正则表达式搜索和替换，返回值为替换后的字符串</p>
<blockquote>
<p>preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) : mixed</p>
<ul>
<li>pattern：要搜索的模式。可以是一个字符串或字符串数组。</li>
<li>replacement：用于替换的字符串或字符串数组</li>
<li>subject：要进行搜索和替换的字符串或字符串数组。</li>
<li>limit：替换的最大次数。默认是 -1(无限)。</li>
<li>count：替换次数。<br />
类似函数<code>preg_filter</code>，参数与<code>preg_replace</code>一致<br />
区别(使用数组进行匹配的时候才看得出区别)：</li>
<li><code>preg_replace</code>：不管是否有替换，返回全部结果</li>
<li><code>preg_filter</code>：只返回匹配的结果。</li>
</ul>
</blockquote>
<h2 id="preg_split">preg_split</h2>
<p>通过一个正则表达式分隔字符串</p>
<blockquote>
<p>preg_split ( string $pattern , string $subject [, int $limit = -1 [, int $flags = 0 ]] ) : array</p>
<ul>
<li>$pattrn：用于搜索的模式，字符串形式。</li>
<li>subject：输入字符串</li>
<li>limit：将限制分隔得到的子串最多只有limit个，返回的最后一个 子串将包含所有剩余部分。</li>
<li>flags：有以下标记的组合：<br />
-- 1. <code>PREG_SPLIT_NO_EMPTY</code>: 返回分隔后的非空部分。<br />
-- 2. <code>PREG_SPLIT_DELIM_CAPTURE</code>: 用分隔符'()'括号把匹配的捕获并返回。<br />
-- 3. <code>PREG_SPLIT_OFFSET_CAPTURE</code>： 匹配返回时将会附加字符串偏移量</li>
</ul>
</blockquote>
<p><code>PREG_SPLIT_DELIM_CAPTURE</code>这个参数可能比较难明白，举个例子看看：</p>
<pre><code><code>$subject = &quot;1a23b&quot;;  
$a = preg_split(&#39;/[\d]/&#39;, $subject, -1, PREG_SPLIT_NO_EMPTY);  
var_dump($a);  
$a = preg_split(&#39;/([\d])/&#39;, $subject, -1, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE); 
var_dump($a);  </code></code></pre>
<p>输出如下：</p>
<blockquote>
<p>array (size=2)<br />
0 =&gt; string 'a' (length=1)<br />
1 =&gt; string 'b' (length=1)<br />
array (size=5)<br />
0 =&gt; string '1' (length=1)<br />
1 =&gt; string 'a' (length=1)<br />
2 =&gt; string '2' (length=1)<br />
3 =&gt; string '3' (length=1)<br />
4 =&gt; string 'b' (length=1)</p>
</blockquote>
<h2 id="preg_grep">preg_grep</h2>
<p>返回匹配模式的数组条目</p>
<blockquote>
<p>preg_grep ( string $pattern , array $input [, int $flags = 0 ] ) : array</p>
<ul>
<li>$pattern：要搜索的模式，字符串形式</li>
<li>$input：输入数组</li>
<li>flags：如果不设置则返回匹配的数目，设置<code>PREG_GREP_INVERT</code>则返回不匹配的数目。</li>
</ul>
</blockquote>
<h2 id="preg_quote">preg_quote</h2>
<p>转义正则表达式字符，返回为转义后的字符串</p>
<blockquote>
<p>preg_quote ( string $str [, string $delimiter = NULL ] ) : string</p>
<ul>
<li>str：输入字符串</li>
<li>delimiter：需要转义的字符串</li>
</ul>
</blockquote>
<p><br></p>
<blockquote>
<p>个人博客网址： <a href="https://colablog.cn/" class="uri">https://colablog.cn/</a></p>
</blockquote>
<p>如果我的文章帮助到您，可以关注我的微信公众号，第一时间分享文章给您</p>
<p><img src="./images/PHP正则表达式，看这一篇就够啦！0.jpg" alt="微信公众号" /></p>


</div></div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>